begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|id
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|IvyPatternHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|plugins
operator|.
name|matcher
operator|.
name|ExactPatternMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|plugins
operator|.
name|matcher
operator|.
name|MapMatcher
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|plugins
operator|.
name|matcher
operator|.
name|PatternMatcher
import|;
end_import

begin_comment
comment|/**  * This class targets to speed up lookup for exact pattern matcher by keys, which are created with  * (organization, module) information. When exact pattern matcher is added, the key is created from  * matcher's attributes. When matcher is looked up against specific module, the key is recreated  * from module's attributes.  *<p>  *</p>  * The lookup doesn't target to speed up lookup for non exact pattern matcher. All non exact  * matchers are placed in non-keyed collection.  *<p>  *</p>  * At lookup for matchers against specific module, all non exact pattern matchers are iterated to  * match with module attributes, and exact pattern matchers binding to the same key will also  * iterated to match with module attributes.  *<p>  *</p>  * If there are much more exact pattern matchers than non exact pattern matchers, the matcher lookup  * speed can benefit from this class significantly. A quick example could be user declares lots of  * dependencyOverrides which are typically exact pattern matchers.  *<p>  *</p>  * If there are balanced exact and non exact pattern matchers, the matcher lookup speed doesn't hurt  * by this class.  *<p>  *</p>  */
end_comment

begin_class
specifier|public
class|class
name|MatcherLookup
block|{
comment|// private static final String FORMAT = "{org:%s, module:%s}";
specifier|private
specifier|static
specifier|final
name|String
name|DEFAULT
init|=
literal|"{org:"
operator|+
literal|"default"
operator|+
literal|", module:"
operator|+
literal|"default"
operator|+
literal|"}"
decl_stmt|;
specifier|private
name|Map
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|MapMatcher
argument_list|>
argument_list|>
name|lookup
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|List
argument_list|<
name|MapMatcher
argument_list|>
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|List
argument_list|<
name|MapMatcher
argument_list|>
name|non_exact_matchers
init|=
operator|new
name|ArrayList
argument_list|<
name|MapMatcher
argument_list|>
argument_list|()
decl_stmt|;
comment|/**      * Add matcher.      *       * If matcher is exact pattern matcher, it will be associated with a key and placed in keyed      * collection.      *       * If matcher is not exact pattern matcher, it will be placed into non-keyed collection      *       * @param matcher MapMatcher      */
specifier|public
name|void
name|add
parameter_list|(
name|MapMatcher
name|matcher
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|matcher
operator|.
name|getPatternMatcher
argument_list|()
operator|instanceof
name|ExactPatternMatcher
operator|)
condition|)
block|{
name|non_exact_matchers
operator|.
name|add
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
return|return;
block|}
name|String
name|key
init|=
name|key
argument_list|(
name|matcher
operator|.
name|getAttributes
argument_list|()
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|MapMatcher
argument_list|>
name|exact_matchers
init|=
name|lookup
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|exact_matchers
operator|==
literal|null
condition|)
block|{
name|exact_matchers
operator|=
operator|new
name|ArrayList
argument_list|<
name|MapMatcher
argument_list|>
argument_list|()
expr_stmt|;
name|lookup
operator|.
name|put
argument_list|(
name|key
argument_list|,
name|exact_matchers
argument_list|)
expr_stmt|;
block|}
name|exact_matchers
operator|.
name|add
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
comment|/**      * Get a list of matchers which can apply to module with specified attributes      *       * @param attrs      *            A map of attributes that matcher should match.      *       * @return list A list of candidate matchers that matches specified attributes      */
specifier|public
name|List
argument_list|<
name|MapMatcher
argument_list|>
name|get
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attrs
parameter_list|)
block|{
name|List
argument_list|<
name|MapMatcher
argument_list|>
name|matchers
init|=
operator|new
name|ArrayList
argument_list|<
name|MapMatcher
argument_list|>
argument_list|()
decl_stmt|;
comment|// Step 1: find matchers from non_exact_matchers list
if|if
condition|(
operator|!
name|non_exact_matchers
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|MapMatcher
name|matcher
range|:
name|non_exact_matchers
control|)
block|{
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|attrs
argument_list|)
condition|)
block|{
name|matchers
operator|.
name|add
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Step 2: find matchers from exact_matchers list of key
name|String
name|key
init|=
name|key
argument_list|(
name|attrs
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|MapMatcher
argument_list|>
name|exact_matchers
init|=
name|lookup
operator|.
name|get
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|exact_matchers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|MapMatcher
name|matcher
range|:
name|exact_matchers
control|)
block|{
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|attrs
argument_list|)
condition|)
block|{
name|matchers
operator|.
name|add
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Step 3: (iff key != DEFAULT) find matchers from exact_matchers of DEFAULT
if|if
condition|(
name|key
operator|!=
name|DEFAULT
condition|)
block|{
name|List
argument_list|<
name|MapMatcher
argument_list|>
name|default_exact_matchers
init|=
name|lookup
operator|.
name|get
argument_list|(
name|DEFAULT
argument_list|)
decl_stmt|;
if|if
condition|(
name|default_exact_matchers
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|MapMatcher
name|matcher
range|:
name|default_exact_matchers
control|)
block|{
if|if
condition|(
name|matcher
operator|.
name|matches
argument_list|(
name|attrs
argument_list|)
condition|)
block|{
name|matchers
operator|.
name|add
argument_list|(
name|matcher
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|matchers
return|;
block|}
comment|/**      * Create a key from specified attributes      *       * @param attrs      *            A map of attributes      * @return key object      */
specifier|private
name|String
name|key
parameter_list|(
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|attrs
parameter_list|)
block|{
name|String
name|org
init|=
name|attrs
operator|.
name|get
argument_list|(
name|IvyPatternHelper
operator|.
name|ORGANISATION_KEY
argument_list|)
decl_stmt|;
name|String
name|module
init|=
name|attrs
operator|.
name|get
argument_list|(
name|IvyPatternHelper
operator|.
name|MODULE_KEY
argument_list|)
decl_stmt|;
if|if
condition|(
name|org
operator|==
literal|null
operator|||
name|PatternMatcher
operator|.
name|ANY_EXPRESSION
operator|.
name|equals
argument_list|(
name|org
argument_list|)
operator|||
name|module
operator|==
literal|null
operator|||
name|PatternMatcher
operator|.
name|ANY_EXPRESSION
operator|.
name|equals
argument_list|(
name|module
argument_list|)
condition|)
block|{
return|return
name|DEFAULT
return|;
block|}
return|return
literal|"{org:"
operator|+
name|org
operator|+
literal|", module:"
operator|+
name|module
operator|+
literal|"}"
return|;
block|}
block|}
end_class

end_unit

