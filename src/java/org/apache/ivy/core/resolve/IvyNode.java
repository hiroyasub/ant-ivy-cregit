begin_unit|revision:1.0.0;language:Java;cregit-version:0.0.1
begin_comment
comment|/*  *  Licensed to the Apache Software Foundation (ASF) under one or more  *  contributor license agreements.  See the NOTICE file distributed with  *  this work for additional information regarding copyright ownership.  *  The ASF licenses this file to You under the Apache License, Version 2.0  *  (the "License"); you may not use this file except in compliance with  *  the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *  Unless required by applicable law or agreed to in writing, software  *  distributed under the License is distributed on an "AS IS" BASIS,  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *  See the License for the specific language governing permissions and  *  limitations under the License.  *  */
end_comment

begin_package
package|package
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|resolve
package|;
end_package

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|ArrayList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Arrays
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collection
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Collections
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|HashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Iterator
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashMap
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedHashSet
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|LinkedList
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|List
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Map
operator|.
name|Entry
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Set
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|Stack
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Matcher
import|;
end_import

begin_import
import|import
name|java
operator|.
name|util
operator|.
name|regex
operator|.
name|Pattern
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|IvyContext
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|LogOptions
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|event
operator|.
name|resolve
operator|.
name|EndResolveDependencyEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|event
operator|.
name|resolve
operator|.
name|StartResolveDependencyEvent
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|Artifact
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|Configuration
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|DefaultArtifact
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|DependencyArtifactDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|DependencyDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|IncludeRule
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|MDArtifact
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|descriptor
operator|.
name|ModuleDescriptor
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|id
operator|.
name|ArtifactId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|id
operator|.
name|ModuleId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|module
operator|.
name|id
operator|.
name|ModuleRevisionId
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|resolve
operator|.
name|IvyNodeCallers
operator|.
name|Caller
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|core
operator|.
name|resolve
operator|.
name|IvyNodeEviction
operator|.
name|EvictionData
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|plugins
operator|.
name|conflict
operator|.
name|ConflictManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|plugins
operator|.
name|conflict
operator|.
name|LatestCompatibleConflictManager
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|plugins
operator|.
name|matcher
operator|.
name|MatcherHelper
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|plugins
operator|.
name|resolver
operator|.
name|DependencyResolver
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|util
operator|.
name|Message
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|util
operator|.
name|StringUtils
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|util
operator|.
name|filter
operator|.
name|Filter
import|;
end_import

begin_import
import|import
name|org
operator|.
name|apache
operator|.
name|ivy
operator|.
name|util
operator|.
name|filter
operator|.
name|FilterHelper
import|;
end_import

begin_class
specifier|public
class|class
name|IvyNode
implements|implements
name|Comparable
argument_list|<
name|IvyNode
argument_list|>
block|{
specifier|private
specifier|static
specifier|final
name|Pattern
name|FALLBACK_CONF_PATTERN
init|=
name|Pattern
operator|.
name|compile
argument_list|(
literal|"(.+)\\((.*)\\)"
argument_list|)
decl_stmt|;
comment|// //////// CONTEXT
specifier|private
name|ResolveData
name|data
decl_stmt|;
specifier|private
name|ResolveEngineSettings
name|settings
decl_stmt|;
comment|// //////// DELEGATES
specifier|private
name|IvyNodeCallers
name|callers
decl_stmt|;
specifier|private
name|IvyNodeEviction
name|eviction
decl_stmt|;
comment|// //////// MAIN DATA
specifier|private
name|IvyNode
name|root
decl_stmt|;
comment|// id as requested, i.e. may be with latest rev
specifier|private
name|ModuleRevisionId
name|id
decl_stmt|;
comment|// set only when node has been built or updated from a DependencyDescriptor
specifier|private
name|Map
argument_list|<
name|IvyNode
argument_list|,
name|DependencyDescriptor
argument_list|>
name|dds
init|=
operator|new
name|HashMap
argument_list|<
name|IvyNode
argument_list|,
name|DependencyDescriptor
argument_list|>
argument_list|()
decl_stmt|;
comment|// Set when data has been loaded only, or when constructed from a module descriptor
specifier|private
name|ModuleDescriptor
name|md
decl_stmt|;
specifier|private
name|ResolvedModuleRevision
name|module
decl_stmt|;
comment|// //////// LOADING METADATA
specifier|private
name|Exception
name|problem
init|=
literal|null
decl_stmt|;
specifier|private
name|boolean
name|downloaded
init|=
literal|false
decl_stmt|;
specifier|private
name|boolean
name|searched
init|=
literal|false
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|confsToFetch
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|fetchedConfigurations
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
specifier|private
name|Collection
argument_list|<
name|String
argument_list|>
name|loadedRootModuleConfs
init|=
operator|new
name|HashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
comment|// //////// USAGE DATA
specifier|private
name|IvyNodeUsage
name|usage
init|=
operator|new
name|IvyNodeUsage
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// usage information merged from evicted nodes this node is "replacing"
specifier|private
name|Map
argument_list|<
name|ModuleRevisionId
argument_list|,
name|IvyNodeUsage
argument_list|>
name|mergedUsages
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|ModuleRevisionId
argument_list|,
name|IvyNodeUsage
argument_list|>
argument_list|()
decl_stmt|;
specifier|public
name|IvyNode
parameter_list|(
name|ResolveData
name|data
parameter_list|,
name|IvyNode
name|parent
parameter_list|,
name|DependencyDescriptor
name|dd
parameter_list|)
block|{
name|id
operator|=
name|dd
operator|.
name|getDependencyRevisionId
argument_list|()
expr_stmt|;
name|dds
operator|.
name|put
argument_list|(
name|parent
argument_list|,
name|dd
argument_list|)
expr_stmt|;
name|root
operator|=
name|parent
operator|.
name|getRoot
argument_list|()
expr_stmt|;
name|init
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
specifier|public
name|IvyNode
parameter_list|(
name|ResolveData
name|data
parameter_list|,
name|ModuleDescriptor
name|md
parameter_list|)
block|{
name|id
operator|=
name|md
operator|.
name|getModuleRevisionId
argument_list|()
expr_stmt|;
name|this
operator|.
name|md
operator|=
name|md
expr_stmt|;
name|root
operator|=
name|this
expr_stmt|;
name|init
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|init
parameter_list|(
name|ResolveData
name|data
parameter_list|)
block|{
name|this
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|settings
operator|=
name|data
operator|.
name|getSettings
argument_list|()
expr_stmt|;
name|eviction
operator|=
operator|new
name|IvyNodeEviction
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|callers
operator|=
operator|new
name|IvyNodeCallers
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
comment|/**      * After the call node may be discarded. To avoid using discarded node, make sure to get the      * real node after the call IvyNode node = ... node.loadData(); node = node.getRealNode(); ...      */
specifier|public
name|boolean
name|loadData
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|IvyNode
name|parent
parameter_list|,
name|String
name|parentConf
parameter_list|,
name|String
name|conf
parameter_list|,
name|boolean
name|shouldBePublic
parameter_list|,
name|IvyNodeUsage
name|usage
parameter_list|)
block|{
name|Message
operator|.
name|debug
argument_list|(
literal|"loadData of "
operator|+
name|this
operator|.
name|toString
argument_list|()
operator|+
literal|" of rootConf="
operator|+
name|rootModuleConf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isRoot
argument_list|()
operator|&&
operator|(
name|data
operator|.
name|getReport
argument_list|()
operator|!=
literal|null
operator|)
condition|)
block|{
name|data
operator|.
name|getReport
argument_list|()
operator|.
name|addDependency
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
name|boolean
name|loaded
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|hasProblem
argument_list|()
condition|)
block|{
name|Message
operator|.
name|debug
argument_list|(
literal|"Node has problem.  Skip loading"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
name|isEvicted
argument_list|(
name|rootModuleConf
argument_list|)
condition|)
block|{
name|Message
operator|.
name|debug
argument_list|(
name|rootModuleConf
operator|+
literal|" is evicted.  Skip loading"
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|hasConfigurationsToLoad
argument_list|()
operator|&&
name|isRootModuleConfLoaded
argument_list|(
name|rootModuleConf
argument_list|)
condition|)
block|{
name|Message
operator|.
name|debug
argument_list|(
name|rootModuleConf
operator|+
literal|" is loaded and no conf to load.  Skip loading"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|markRootModuleConfLoaded
argument_list|(
name|rootModuleConf
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
name|DependencyResolver
name|resolver
init|=
name|data
operator|.
name|getSettings
argument_list|()
operator|.
name|getResolver
argument_list|(
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolver
operator|==
literal|null
condition|)
block|{
name|Message
operator|.
name|error
argument_list|(
literal|"no resolver found for "
operator|+
name|getModuleId
argument_list|()
operator|+
literal|": check your configuration"
argument_list|)
expr_stmt|;
name|problem
operator|=
operator|new
name|RuntimeException
argument_list|(
literal|"no resolver found for "
operator|+
name|getModuleId
argument_list|()
operator|+
literal|": check your configuration"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
try|try
block|{
name|Message
operator|.
name|debug
argument_list|(
literal|"\tusing "
operator|+
name|resolver
operator|+
literal|" to resolve "
operator|+
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|DependencyDescriptor
name|dependencyDescriptor
init|=
name|getDependencyDescriptor
argument_list|(
name|parent
argument_list|)
decl_stmt|;
name|long
name|start
init|=
name|System
operator|.
name|currentTimeMillis
argument_list|()
decl_stmt|;
name|ModuleRevisionId
name|requestedRevisionId
init|=
name|dependencyDescriptor
operator|.
name|getDependencyRevisionId
argument_list|()
decl_stmt|;
name|data
operator|.
name|getEventManager
argument_list|()
operator|.
name|fireIvyEvent
argument_list|(
operator|new
name|StartResolveDependencyEvent
argument_list|(
name|resolver
argument_list|,
name|dependencyDescriptor
argument_list|,
name|requestedRevisionId
argument_list|)
argument_list|)
expr_stmt|;
name|module
operator|=
name|resolver
operator|.
name|getDependency
argument_list|(
name|dependencyDescriptor
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|.
name|getEventManager
argument_list|()
operator|.
name|fireIvyEvent
argument_list|(
operator|new
name|EndResolveDependencyEvent
argument_list|(
name|resolver
argument_list|,
name|dependencyDescriptor
argument_list|,
name|requestedRevisionId
argument_list|,
name|module
argument_list|,
name|System
operator|.
name|currentTimeMillis
argument_list|()
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|module
operator|!=
literal|null
condition|)
block|{
name|module
operator|.
name|getResolver
argument_list|()
operator|.
name|getRepositoryCacheManager
argument_list|()
operator|.
name|saveResolvers
argument_list|(
name|module
operator|.
name|getDescriptor
argument_list|()
argument_list|,
name|module
operator|.
name|getResolver
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|,
name|module
operator|.
name|getArtifactResolver
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|settings
operator|.
name|logModuleWhenFound
argument_list|()
operator|&&
name|LogOptions
operator|.
name|LOG_DEFAULT
operator|.
name|equals
argument_list|(
name|getData
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getLog
argument_list|()
argument_list|)
condition|)
block|{
name|Message
operator|.
name|info
argument_list|(
literal|"\tfound "
operator|+
name|module
operator|.
name|getId
argument_list|()
operator|+
literal|" in "
operator|+
name|module
operator|.
name|getResolver
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Message
operator|.
name|verbose
argument_list|(
literal|"\tfound "
operator|+
name|module
operator|.
name|getId
argument_list|()
operator|+
literal|" in "
operator|+
name|module
operator|.
name|getResolver
argument_list|()
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// IVY-56: check if revision has actually been resolved
if|if
condition|(
name|settings
operator|.
name|getVersionMatcher
argument_list|()
operator|.
name|isDynamic
argument_list|(
name|getId
argument_list|()
argument_list|)
operator|&&
name|settings
operator|.
name|getVersionMatcher
argument_list|()
operator|.
name|isDynamic
argument_list|(
name|module
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|Message
operator|.
name|error
argument_list|(
literal|"impossible to resolve dynamic revision for "
operator|+
name|getId
argument_list|()
operator|+
literal|": check your configuration and make sure revision is part of your pattern"
argument_list|)
expr_stmt|;
name|problem
operator|=
operator|new
name|RuntimeException
argument_list|(
literal|"impossible to resolve dynamic revision"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|module
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|IvyNode
name|resolved
init|=
name|data
operator|.
name|getNode
argument_list|(
name|module
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolved
operator|!=
literal|null
condition|)
block|{
comment|// found revision has already been resolved
comment|// => update it and discard this node
name|md
operator|=
name|module
operator|.
name|getDescriptor
argument_list|()
expr_stmt|;
comment|// needed for handleConfiguration
if|if
condition|(
operator|!
name|handleConfiguration
argument_list|(
name|loaded
argument_list|,
name|rootModuleConf
argument_list|,
name|parent
argument_list|,
name|parentConf
argument_list|,
name|conf
argument_list|,
name|shouldBePublic
argument_list|,
name|usage
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|moveToRealNode
argument_list|(
name|rootModuleConf
argument_list|,
name|parent
argument_list|,
name|parentConf
argument_list|,
name|conf
argument_list|,
name|shouldBePublic
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|String
name|log
init|=
literal|"\t["
operator|+
name|module
operator|.
name|getId
argument_list|()
operator|.
name|getRevision
argument_list|()
operator|+
literal|"] "
operator|+
name|getId
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|settings
operator|.
name|getVersionMatcher
argument_list|()
operator|.
name|isDynamic
argument_list|(
name|getId
argument_list|()
argument_list|)
condition|)
block|{
name|log
operator|+=
literal|" (forced)"
expr_stmt|;
block|}
if|if
condition|(
name|settings
operator|.
name|logResolvedRevision
argument_list|()
operator|&&
name|LogOptions
operator|.
name|LOG_DEFAULT
operator|.
name|equals
argument_list|(
name|getData
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getLog
argument_list|()
argument_list|)
condition|)
block|{
name|Message
operator|.
name|info
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Message
operator|.
name|verbose
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
block|}
name|downloaded
operator|=
name|module
operator|.
name|getReport
argument_list|()
operator|.
name|isDownloaded
argument_list|()
expr_stmt|;
name|searched
operator|=
name|module
operator|.
name|getReport
argument_list|()
operator|.
name|isSearched
argument_list|()
expr_stmt|;
name|loaded
operator|=
literal|true
expr_stmt|;
name|md
operator|=
name|module
operator|.
name|getDescriptor
argument_list|()
expr_stmt|;
name|confsToFetch
operator|.
name|remove
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|updateConfsToFetch
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|resolveSpecialConfigurations
argument_list|(
name|getRequiredConfigurations
argument_list|(
name|parent
argument_list|,
name|parentConf
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Message
operator|.
name|warn
argument_list|(
literal|"\tmodule not found: "
operator|+
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|resolver
operator|.
name|reportFailure
argument_list|()
expr_stmt|;
name|problem
operator|=
operator|new
name|RuntimeException
argument_list|(
literal|"not found"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
catch|catch
parameter_list|(
name|ResolveProcessException
name|e
parameter_list|)
block|{
throw|throw
name|e
throw|;
block|}
catch|catch
parameter_list|(
name|Exception
name|e
parameter_list|)
block|{
name|problem
operator|=
name|e
expr_stmt|;
name|Message
operator|.
name|debug
argument_list|(
literal|"Unexpected error: "
operator|+
name|problem
operator|.
name|getMessage
argument_list|()
argument_list|,
name|problem
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|loaded
operator|=
literal|true
expr_stmt|;
block|}
block|}
name|handleConfiguration
argument_list|(
name|loaded
argument_list|,
name|rootModuleConf
argument_list|,
name|parent
argument_list|,
name|parentConf
argument_list|,
name|conf
argument_list|,
name|shouldBePublic
argument_list|,
name|usage
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasProblem
argument_list|()
condition|)
block|{
name|Message
operator|.
name|debug
argument_list|(
literal|"problem : "
operator|+
name|problem
operator|.
name|getMessage
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|DependencyDescriptor
name|dd
init|=
name|getDependencyDescriptor
argument_list|(
name|parent
argument_list|)
decl_stmt|;
if|if
condition|(
name|dd
operator|!=
literal|null
condition|)
block|{
name|usage
operator|.
name|addUsage
argument_list|(
name|rootModuleConf
argument_list|,
name|dd
argument_list|,
name|parentConf
argument_list|)
expr_stmt|;
block|}
return|return
name|loaded
return|;
block|}
specifier|private
name|void
name|moveToRealNode
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|IvyNode
name|parent
parameter_list|,
name|String
name|parentConf
parameter_list|,
name|String
name|conf
parameter_list|,
name|boolean
name|shouldBePublic
parameter_list|,
name|IvyNode
name|resolved
parameter_list|)
block|{
if|if
condition|(
name|resolved
operator|.
name|md
operator|==
literal|null
condition|)
block|{
name|resolved
operator|.
name|md
operator|=
name|md
expr_stmt|;
block|}
if|if
condition|(
name|resolved
operator|.
name|module
operator|==
literal|null
condition|)
block|{
name|resolved
operator|.
name|module
operator|=
name|module
expr_stmt|;
block|}
name|resolved
operator|.
name|downloaded
operator||=
name|module
operator|.
name|getReport
argument_list|()
operator|.
name|isDownloaded
argument_list|()
expr_stmt|;
name|resolved
operator|.
name|searched
operator||=
name|module
operator|.
name|getReport
argument_list|()
operator|.
name|isSearched
argument_list|()
expr_stmt|;
name|resolved
operator|.
name|dds
operator|.
name|putAll
argument_list|(
name|dds
argument_list|)
expr_stmt|;
name|resolved
operator|.
name|updateDataFrom
argument_list|(
name|this
argument_list|,
name|rootModuleConf
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|resolved
operator|.
name|loadData
argument_list|(
name|rootModuleConf
argument_list|,
name|parent
argument_list|,
name|parentConf
argument_list|,
name|conf
argument_list|,
name|shouldBePublic
argument_list|,
name|usage
argument_list|)
expr_stmt|;
name|resolved
operator|.
name|usage
operator|.
name|updateDataFrom
argument_list|(
name|getAllUsages
argument_list|()
argument_list|,
name|rootModuleConf
argument_list|)
expr_stmt|;
name|usage
operator|=
name|resolved
operator|.
name|usage
expr_stmt|;
name|data
operator|.
name|replaceNode
argument_list|(
name|getId
argument_list|()
argument_list|,
name|resolved
argument_list|,
name|rootModuleConf
argument_list|)
expr_stmt|;
comment|// this actually discards the node
if|if
condition|(
name|settings
operator|.
name|logResolvedRevision
argument_list|()
operator|&&
name|LogOptions
operator|.
name|LOG_DEFAULT
operator|.
name|equals
argument_list|(
name|getData
argument_list|()
operator|.
name|getOptions
argument_list|()
operator|.
name|getLog
argument_list|()
argument_list|)
condition|)
block|{
name|Message
operator|.
name|info
argument_list|(
literal|"\t["
operator|+
name|module
operator|.
name|getId
argument_list|()
operator|.
name|getRevision
argument_list|()
operator|+
literal|"] "
operator|+
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Message
operator|.
name|verbose
argument_list|(
literal|"\t["
operator|+
name|module
operator|.
name|getId
argument_list|()
operator|.
name|getRevision
argument_list|()
operator|+
literal|"] "
operator|+
name|getId
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|getDependencies
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|String
index|[]
name|confs
parameter_list|,
name|String
name|requestedConf
parameter_list|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"impossible to get dependencies when data has not been loaded"
argument_list|)
throw|;
block|}
if|if
condition|(
name|Arrays
operator|.
name|asList
argument_list|(
name|confs
argument_list|)
operator|.
name|contains
argument_list|(
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|isRoot
argument_list|()
condition|)
block|{
name|confs
operator|=
name|md
operator|.
name|getConfigurationsNames
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|confs
operator|=
name|md
operator|.
name|getPublicConfigurationsNames
argument_list|()
expr_stmt|;
block|}
block|}
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|deps
init|=
operator|new
name|HashSet
argument_list|<
name|IvyNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|confs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|deps
operator|.
name|addAll
argument_list|(
name|getDependencies
argument_list|(
name|rootModuleConf
argument_list|,
name|confs
index|[
name|i
index|]
argument_list|,
name|requestedConf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|deps
return|;
block|}
comment|/**      * Load the dependencies of the current node      *<p>      * The resulting collection of nodes may have some configuration to load      *       * @param rootModuleConf      *            the requested configuration of the root module      * @param conf      *            the configuration to load of this node      * @param requestedConf      *            the actual node conf requested, possibly extending the<code>conf</code> one.      * @return {@link Collection} of {@link IvyNode}      */
specifier|public
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|getDependencies
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|String
name|conf
parameter_list|,
name|String
name|requestedConf
parameter_list|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"impossible to get dependencies when data has not been loaded"
argument_list|)
throw|;
block|}
name|DependencyDescriptor
index|[]
name|dds
init|=
name|md
operator|.
name|getDependencies
argument_list|()
decl_stmt|;
comment|// it's important to respect order => LinkedHashMap
name|Map
argument_list|<
name|ModuleRevisionId
argument_list|,
name|IvyNode
argument_list|>
name|dependencies
init|=
operator|new
name|LinkedHashMap
argument_list|<
name|ModuleRevisionId
argument_list|,
name|IvyNode
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|DependencyDescriptor
name|dependencyDescriptor
range|:
name|dds
control|)
block|{
name|DependencyDescriptor
name|dd
init|=
name|data
operator|.
name|mediate
argument_list|(
name|dependencyDescriptor
argument_list|)
decl_stmt|;
name|String
index|[]
name|dependencyConfigurations
init|=
name|dd
operator|.
name|getDependencyConfigurations
argument_list|(
name|conf
argument_list|,
name|requestedConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|dependencyConfigurations
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// no configuration of the dependency is required for current confs :
comment|// it is exactly the same as if there was no dependency at all on it
continue|continue;
block|}
name|ModuleRevisionId
name|requestedDependencyRevisionId
init|=
name|dd
operator|.
name|getDependencyRevisionId
argument_list|()
decl_stmt|;
if|if
condition|(
name|isDependencyModuleExcluded
argument_list|(
name|dd
argument_list|,
name|rootModuleConf
argument_list|,
name|requestedDependencyRevisionId
argument_list|,
name|conf
argument_list|)
condition|)
block|{
comment|// the whole module is excluded, it is considered as not being part of dependencies
comment|// at all
name|Message
operator|.
name|verbose
argument_list|(
literal|"excluding "
operator|+
name|dd
operator|+
literal|" in "
operator|+
name|conf
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|// check if not already loaded here
name|IvyNode
name|depNode
init|=
name|dependencies
operator|.
name|get
argument_list|(
name|requestedDependencyRevisionId
argument_list|)
decl_stmt|;
if|if
condition|(
name|depNode
operator|==
literal|null
condition|)
block|{
comment|// check if not already loaded during the resolve session
name|depNode
operator|=
name|data
operator|.
name|getNode
argument_list|(
name|requestedDependencyRevisionId
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depNode
operator|==
literal|null
condition|)
block|{
name|depNode
operator|=
operator|new
name|IvyNode
argument_list|(
name|data
argument_list|,
name|this
argument_list|,
name|dd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|depNode
operator|.
name|addDependencyDescriptor
argument_list|(
name|this
argument_list|,
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|depNode
operator|.
name|hasProblem
argument_list|()
condition|)
block|{
comment|// dependency already tried to be resolved, but unsuccessfully
comment|// nothing special to do
block|}
block|}
name|String
index|[]
name|confsArray
init|=
name|depNode
operator|.
name|resolveSpecialConfigurations
argument_list|(
name|dependencyConfigurations
argument_list|)
decl_stmt|;
name|Collection
argument_list|<
name|String
argument_list|>
name|confs
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|confsArray
argument_list|)
decl_stmt|;
name|depNode
operator|.
name|updateConfsToFetch
argument_list|(
name|confs
argument_list|)
expr_stmt|;
name|depNode
operator|.
name|addRootModuleConfigurations
argument_list|(
name|depNode
operator|.
name|usage
argument_list|,
name|rootModuleConf
argument_list|,
name|confsArray
argument_list|)
expr_stmt|;
name|depNode
operator|.
name|usage
operator|.
name|setRequiredConfs
argument_list|(
name|this
argument_list|,
name|conf
argument_list|,
name|confs
argument_list|)
expr_stmt|;
name|depNode
operator|.
name|addCaller
argument_list|(
name|rootModuleConf
argument_list|,
name|this
argument_list|,
name|conf
argument_list|,
name|requestedConf
argument_list|,
name|dependencyConfigurations
argument_list|,
name|dd
argument_list|)
expr_stmt|;
name|dependencies
operator|.
name|put
argument_list|(
name|requestedDependencyRevisionId
argument_list|,
name|depNode
argument_list|)
expr_stmt|;
block|}
return|return
name|dependencies
operator|.
name|values
argument_list|()
return|;
block|}
specifier|private
name|void
name|addDependencyDescriptor
parameter_list|(
name|IvyNode
name|parent
parameter_list|,
name|DependencyDescriptor
name|dd
parameter_list|)
block|{
name|dds
operator|.
name|put
argument_list|(
name|parent
argument_list|,
name|dd
argument_list|)
expr_stmt|;
block|}
specifier|public
name|DependencyDescriptor
name|getDependencyDescriptor
parameter_list|(
name|IvyNode
name|parent
parameter_list|)
block|{
return|return
name|dds
operator|.
name|get
argument_list|(
name|parent
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isDependencyModuleExcluded
parameter_list|(
name|DependencyDescriptor
name|dd
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|ModuleRevisionId
name|dependencyRevisionId
parameter_list|,
name|String
name|conf
parameter_list|)
block|{
name|Artifact
name|a
init|=
name|DefaultArtifact
operator|.
name|newIvyArtifact
argument_list|(
name|dependencyRevisionId
argument_list|,
literal|null
argument_list|)
decl_stmt|;
if|if
condition|(
name|isRoot
argument_list|()
condition|)
block|{
comment|// no callers, but maybe some exclude
name|Boolean
name|exclude
init|=
name|doesExclude
argument_list|(
name|md
argument_list|,
name|rootModuleConf
argument_list|,
operator|new
name|String
index|[]
block|{
name|rootModuleConf
block|}
argument_list|,
name|dd
argument_list|,
name|a
argument_list|,
operator|new
name|Stack
argument_list|<
name|ModuleRevisionId
argument_list|>
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|exclude
operator|!=
literal|null
operator|&&
name|exclude
return|;
block|}
return|return
name|callers
operator|.
name|doesCallersExclude
argument_list|(
name|rootModuleConf
argument_list|,
name|a
argument_list|)
return|;
block|}
name|Boolean
name|doesExclude
parameter_list|(
name|ModuleDescriptor
name|md
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|String
index|[]
name|moduleConfs
parameter_list|,
name|DependencyDescriptor
name|dd
parameter_list|,
name|Artifact
name|artifact
parameter_list|,
name|Stack
argument_list|<
name|ModuleRevisionId
argument_list|>
name|callersStack
parameter_list|)
block|{
comment|// artifact is excluded if it match any of the exclude pattern for this dependency...
if|if
condition|(
name|dd
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|dd
operator|.
name|doesExclude
argument_list|(
name|moduleConfs
argument_list|,
name|artifact
operator|.
name|getId
argument_list|()
operator|.
name|getArtifactId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|Boolean
operator|.
name|TRUE
return|;
block|}
block|}
if|if
condition|(
name|md
operator|.
name|doesExclude
argument_list|(
name|moduleConfs
argument_list|,
name|artifact
operator|.
name|getId
argument_list|()
operator|.
name|getArtifactId
argument_list|()
argument_list|)
condition|)
block|{
return|return
name|Boolean
operator|.
name|TRUE
return|;
block|}
comment|// ... or if it is excluded by all its callers
name|IvyNode
name|c
init|=
name|getData
argument_list|()
operator|.
name|getNode
argument_list|(
name|md
operator|.
name|getModuleRevisionId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|!=
literal|null
condition|)
block|{
if|if
condition|(
name|callersStack
operator|.
name|contains
argument_list|(
name|c
operator|.
name|getId
argument_list|()
argument_list|)
condition|)
block|{
comment|// a circular dependency, we cannot be conclusive here
return|return
literal|null
return|;
block|}
return|return
name|Boolean
operator|.
name|valueOf
argument_list|(
name|c
operator|.
name|doesCallersExclude
argument_list|(
name|rootModuleConf
argument_list|,
name|artifact
argument_list|,
name|callersStack
argument_list|)
argument_list|)
return|;
block|}
return|return
name|Boolean
operator|.
name|FALSE
return|;
block|}
specifier|public
name|boolean
name|hasConfigurationsToLoad
parameter_list|()
block|{
return|return
operator|!
name|confsToFetch
operator|.
name|isEmpty
argument_list|()
return|;
block|}
specifier|private
name|boolean
name|markRootModuleConfLoaded
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|loadedRootModuleConfs
operator|.
name|add
argument_list|(
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|isRootModuleConfLoaded
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|loadedRootModuleConfs
operator|.
name|contains
argument_list|(
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|private
name|boolean
name|handleConfiguration
parameter_list|(
name|boolean
name|loaded
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|IvyNode
name|parent
parameter_list|,
name|String
name|parentConf
parameter_list|,
name|String
name|conf
parameter_list|,
name|boolean
name|shouldBePublic
parameter_list|,
name|IvyNodeUsage
name|usage
parameter_list|)
block|{
if|if
condition|(
name|md
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|confs
init|=
name|getRealConfs
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|addRootModuleConfigurations
argument_list|(
name|usage
argument_list|,
name|rootModuleConf
argument_list|,
name|confs
argument_list|)
expr_stmt|;
for|for
control|(
name|String
name|realConf
range|:
name|confs
control|)
block|{
name|Configuration
name|c
init|=
name|md
operator|.
name|getConfiguration
argument_list|(
name|realConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|null
condition|)
block|{
name|confsToFetch
operator|.
name|remove
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isConfRequiredByMergedUsageOnly
argument_list|(
name|rootModuleConf
argument_list|,
name|conf
argument_list|)
condition|)
block|{
name|Message
operator|.
name|verbose
argument_list|(
literal|"configuration required by evicted revision is not available in "
operator|+
literal|"selected revision. skipping "
operator|+
name|conf
operator|+
literal|" in "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
if|else if
condition|(
operator|!
name|conf
operator|.
name|equals
argument_list|(
name|realConf
argument_list|)
condition|)
block|{
name|problem
operator|=
operator|new
name|RuntimeException
argument_list|(
literal|"configuration not found in "
operator|+
name|this
operator|+
literal|": '"
operator|+
name|conf
operator|+
literal|"'. Missing configuration: '"
operator|+
name|realConf
operator|+
literal|"'. It was required from "
operator|+
name|parent
operator|+
literal|" "
operator|+
name|parentConf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|problem
operator|=
operator|new
name|RuntimeException
argument_list|(
literal|"configuration not found in "
operator|+
name|this
operator|+
literal|": '"
operator|+
name|realConf
operator|+
literal|"'. It was required from "
operator|+
name|parent
operator|+
literal|" "
operator|+
name|parentConf
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
if|if
condition|(
name|shouldBePublic
operator|&&
operator|!
name|isRoot
argument_list|()
operator|&&
name|c
operator|.
name|getVisibility
argument_list|()
operator|!=
name|Configuration
operator|.
name|Visibility
operator|.
name|PUBLIC
condition|)
block|{
name|confsToFetch
operator|.
name|remove
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isConfRequiredByMergedUsageOnly
argument_list|(
name|rootModuleConf
argument_list|,
name|conf
argument_list|)
condition|)
block|{
name|Message
operator|.
name|verbose
argument_list|(
literal|"configuration required by evicted revision is not visible in "
operator|+
literal|"selected revision. skipping "
operator|+
name|conf
operator|+
literal|" in "
operator|+
name|this
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|problem
operator|=
operator|new
name|RuntimeException
argument_list|(
literal|"configuration not public in "
operator|+
name|this
operator|+
literal|": '"
operator|+
name|c
operator|+
literal|"'. It was required from "
operator|+
name|parent
operator|+
literal|" "
operator|+
name|parentConf
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
name|loaded
condition|)
block|{
name|fetchedConfigurations
operator|.
name|add
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|confsToFetch
operator|.
name|removeAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|confs
argument_list|)
argument_list|)
expr_stmt|;
name|confsToFetch
operator|.
name|remove
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|true
return|;
block|}
specifier|private
name|String
name|getDefaultConf
parameter_list|(
name|String
name|conf
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|FALLBACK_CONF_PATTERN
operator|.
name|matcher
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|m
operator|.
name|matches
argument_list|()
condition|?
name|m
operator|.
name|group
argument_list|(
literal|2
argument_list|)
else|:
name|conf
return|;
block|}
specifier|private
name|String
name|getMainConf
parameter_list|(
name|String
name|conf
parameter_list|)
block|{
name|Matcher
name|m
init|=
name|FALLBACK_CONF_PATTERN
operator|.
name|matcher
argument_list|(
name|conf
argument_list|)
decl_stmt|;
return|return
name|m
operator|.
name|matches
argument_list|()
condition|?
name|m
operator|.
name|group
argument_list|(
literal|1
argument_list|)
else|:
literal|null
return|;
block|}
specifier|public
name|void
name|updateConfsToFetch
parameter_list|(
name|Collection
argument_list|<
name|String
argument_list|>
name|confs
parameter_list|)
block|{
name|confsToFetch
operator|.
name|addAll
argument_list|(
name|confs
argument_list|)
expr_stmt|;
name|confsToFetch
operator|.
name|removeAll
argument_list|(
name|fetchedConfigurations
argument_list|)
expr_stmt|;
block|}
comment|/**      * resolve the '*' special configurations if necessary and possible      */
specifier|private
name|String
index|[]
name|resolveSpecialConfigurations
parameter_list|(
name|String
index|[]
name|dependencyConfigurations
parameter_list|)
block|{
if|if
condition|(
name|dependencyConfigurations
operator|.
name|length
operator|==
literal|1
operator|&&
name|dependencyConfigurations
index|[
literal|0
index|]
operator|.
name|startsWith
argument_list|(
literal|"*"
argument_list|)
operator|&&
name|isLoaded
argument_list|()
condition|)
block|{
name|String
name|conf
init|=
name|dependencyConfigurations
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
literal|"*"
operator|.
name|equals
argument_list|(
name|conf
argument_list|)
condition|)
block|{
return|return
name|getDescriptor
argument_list|()
operator|.
name|getPublicConfigurationsNames
argument_list|()
return|;
block|}
comment|// there are exclusions in the configuration
name|List
argument_list|<
name|String
argument_list|>
name|exclusions
init|=
name|Arrays
operator|.
name|asList
argument_list|(
name|conf
operator|.
name|substring
argument_list|(
literal|2
argument_list|)
operator|.
name|split
argument_list|(
literal|"\\!"
argument_list|)
argument_list|)
decl_stmt|;
name|List
argument_list|<
name|String
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getDescriptor
argument_list|()
operator|.
name|getPublicConfigurationsNames
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|ret
operator|.
name|removeAll
argument_list|(
name|exclusions
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|ret
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
return|return
name|dependencyConfigurations
return|;
block|}
comment|/**      * returns the required configurations from the given node      *       * @param in IvyNode      * @param inConf ditto      * @return array of configuration names      */
specifier|public
name|String
index|[]
name|getRequiredConfigurations
parameter_list|(
name|IvyNode
name|in
parameter_list|,
name|String
name|inConf
parameter_list|)
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|req
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|addAllIfNotNull
argument_list|(
name|req
argument_list|,
name|usage
operator|.
name|getRequiredConfigurations
argument_list|(
name|in
argument_list|,
name|inConf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|IvyNodeUsage
name|usage
range|:
name|mergedUsages
operator|.
name|values
argument_list|()
control|)
block|{
name|addAllIfNotNull
argument_list|(
name|req
argument_list|,
name|usage
operator|.
name|getRequiredConfigurations
argument_list|(
name|in
argument_list|,
name|inConf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|req
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|req
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|private
parameter_list|<
name|T
parameter_list|>
name|void
name|addAllIfNotNull
parameter_list|(
name|Collection
argument_list|<
name|T
argument_list|>
name|into
parameter_list|,
name|Collection
argument_list|<
name|T
argument_list|>
name|col
parameter_list|)
block|{
if|if
condition|(
name|col
operator|!=
literal|null
condition|)
block|{
name|into
operator|.
name|addAll
argument_list|(
name|col
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**      * returns all the current required configurations of the node      *       * @return array of configuration names      */
specifier|public
name|String
index|[]
name|getRequiredConfigurations
parameter_list|()
block|{
name|Collection
argument_list|<
name|String
argument_list|>
name|required
init|=
operator|new
name|ArrayList
argument_list|<
name|String
argument_list|>
argument_list|(
name|confsToFetch
operator|.
name|size
argument_list|()
operator|+
name|fetchedConfigurations
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|required
operator|.
name|addAll
argument_list|(
name|fetchedConfigurations
argument_list|)
expr_stmt|;
name|required
operator|.
name|addAll
argument_list|(
name|confsToFetch
argument_list|)
expr_stmt|;
return|return
name|required
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|required
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|public
name|Configuration
name|getConfiguration
parameter_list|(
name|String
name|conf
parameter_list|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"impossible to get configuration when data has not been loaded"
argument_list|)
throw|;
block|}
name|String
name|defaultConf
init|=
name|getDefaultConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|conf
operator|=
name|getMainConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
name|Configuration
name|configuration
init|=
name|md
operator|.
name|getConfiguration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|configuration
operator|==
literal|null
condition|)
block|{
name|configuration
operator|=
name|md
operator|.
name|getConfiguration
argument_list|(
name|defaultConf
argument_list|)
expr_stmt|;
block|}
return|return
name|configuration
return|;
block|}
comment|/**      * Returns the configurations of the dependency required in a given root module configuration.      *       * @param rootModuleConf String      * @return array of configuration names      */
specifier|public
name|String
index|[]
name|getConfigurations
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|depConfs
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|addAllIfNotNull
argument_list|(
name|depConfs
argument_list|,
name|usage
operator|.
name|getConfigurations
argument_list|(
name|rootModuleConf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|IvyNodeUsage
name|usage
range|:
name|mergedUsages
operator|.
name|values
argument_list|()
control|)
block|{
name|addAllIfNotNull
argument_list|(
name|depConfs
argument_list|,
name|usage
operator|.
name|getConfigurations
argument_list|(
name|rootModuleConf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|depConfs
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|depConfs
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|protected
name|boolean
name|isConfRequiredByMergedUsageOnly
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|String
name|conf
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|confs
init|=
name|usage
operator|.
name|getConfigurations
argument_list|(
name|rootModuleConf
argument_list|)
decl_stmt|;
return|return
name|confs
operator|==
literal|null
operator|||
operator|!
name|confs
operator|.
name|contains
argument_list|(
name|conf
argument_list|)
return|;
block|}
comment|// This is never called. Could we remove it?
specifier|public
name|void
name|discardConf
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|String
name|conf
parameter_list|)
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|depConfs
init|=
name|usage
operator|.
name|addAndGetConfigurations
argument_list|(
name|rootModuleConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|md
operator|!=
literal|null
condition|)
block|{
comment|// remove all given dependency configurations to the set + extended ones
name|Configuration
name|c
init|=
name|md
operator|.
name|getConfiguration
argument_list|(
name|conf
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
name|String
index|[]
name|exts
init|=
name|c
operator|.
name|getExtends
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|exts
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|discardConf
argument_list|(
name|rootModuleConf
argument_list|,
name|exts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|// recursive remove of extended
comment|// configurations
block|}
name|depConfs
operator|.
name|remove
argument_list|(
name|c
operator|.
name|getName
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Message
operator|.
name|warn
argument_list|(
literal|"unknown configuration in "
operator|+
name|getId
argument_list|()
operator|+
literal|": "
operator|+
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|depConfs
operator|.
name|remove
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addRootModuleConfigurations
parameter_list|(
name|IvyNodeUsage
name|usage
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|String
index|[]
name|dependencyConfs
parameter_list|)
block|{
if|if
condition|(
name|md
operator|!=
literal|null
condition|)
block|{
comment|// add all given dependency configurations to the set + extended ones
for|for
control|(
name|String
name|dependencyConf
range|:
name|dependencyConfs
control|)
block|{
name|Configuration
name|conf
init|=
name|md
operator|.
name|getConfiguration
argument_list|(
name|dependencyConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|conf
operator|!=
literal|null
condition|)
block|{
comment|// recursive add of extended
name|addRootModuleConfigurations
argument_list|(
name|usage
argument_list|,
name|rootModuleConf
argument_list|,
name|conf
operator|.
name|getExtends
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Collections
operator|.
name|addAll
argument_list|(
name|usage
operator|.
name|addAndGetConfigurations
argument_list|(
name|rootModuleConf
argument_list|)
argument_list|,
name|dependencyConfs
argument_list|)
expr_stmt|;
block|}
comment|/**      * Returns the root module configurations in which this dependency is required      *       * @return array of configuration names      */
specifier|public
name|String
index|[]
name|getRootModuleConfigurations
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|confs
init|=
name|getRootModuleConfigurationsSet
argument_list|()
decl_stmt|;
return|return
name|confs
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|confs
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Returns the root module configurations in which this dependency is required      *       * @return {@link Set} of configuration names      */
specifier|public
name|Set
argument_list|<
name|String
argument_list|>
name|getRootModuleConfigurationsSet
parameter_list|()
block|{
name|Set
argument_list|<
name|String
argument_list|>
name|confs
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|String
argument_list|>
argument_list|()
decl_stmt|;
name|addAllIfNotNull
argument_list|(
name|confs
argument_list|,
name|usage
operator|.
name|getRootModuleConfigurations
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|IvyNodeUsage
name|usage
range|:
name|mergedUsages
operator|.
name|values
argument_list|()
control|)
block|{
name|addAllIfNotNull
argument_list|(
name|confs
argument_list|,
name|usage
operator|.
name|getRootModuleConfigurations
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|confs
return|;
block|}
specifier|public
name|String
index|[]
name|getConfsToFetch
parameter_list|()
block|{
return|return
name|confsToFetch
operator|.
name|toArray
argument_list|(
operator|new
name|String
index|[
name|confsToFetch
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|public
name|String
index|[]
name|getRealConfs
parameter_list|(
name|String
name|conf
parameter_list|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
return|return
operator|new
name|String
index|[]
block|{
name|conf
block|}
return|;
block|}
name|String
name|defaultConf
init|=
name|getDefaultConf
argument_list|(
name|conf
argument_list|)
decl_stmt|;
name|conf
operator|=
name|getMainConf
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|md
operator|.
name|getConfiguration
argument_list|(
name|conf
argument_list|)
operator|==
literal|null
operator|)
operator|||
name|Configuration
operator|.
name|Visibility
operator|.
name|PRIVATE
operator|.
name|equals
argument_list|(
name|md
operator|.
name|getConfiguration
argument_list|(
name|conf
argument_list|)
operator|.
name|getVisibility
argument_list|()
argument_list|)
condition|)
block|{
if|if
condition|(
literal|""
operator|.
name|equals
argument_list|(
name|defaultConf
argument_list|)
condition|)
block|{
return|return
operator|new
name|String
index|[
literal|0
index|]
return|;
block|}
name|conf
operator|=
name|defaultConf
expr_stmt|;
block|}
if|if
condition|(
name|conf
operator|.
name|charAt
argument_list|(
literal|0
argument_list|)
operator|==
literal|'*'
condition|)
block|{
return|return
name|resolveSpecialConfigurations
argument_list|(
operator|new
name|String
index|[]
block|{
name|conf
block|}
argument_list|)
return|;
block|}
if|if
condition|(
name|conf
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|String
index|[]
name|confs
init|=
name|conf
operator|.
name|split
argument_list|(
literal|","
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|confs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|confs
index|[
name|i
index|]
operator|=
name|confs
index|[
name|i
index|]
operator|.
name|trim
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|new
name|String
index|[]
block|{
name|conf
block|}
return|;
block|}
comment|/**      * Finds and returns a path in callers from the given module id to the current node      *       * @param from      *            the module id to start the path from      * @return a collection representing the path, starting with the from node, followed by the list      *         of nodes being one path to the current node, excluded      */
specifier|private
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|findPath
parameter_list|(
name|ModuleId
name|from
parameter_list|)
block|{
return|return
name|findPath
argument_list|(
name|from
argument_list|,
name|this
argument_list|,
operator|new
name|LinkedList
argument_list|<
name|IvyNode
argument_list|>
argument_list|()
argument_list|)
return|;
block|}
specifier|private
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|findPath
parameter_list|(
name|ModuleId
name|from
parameter_list|,
name|IvyNode
name|node
parameter_list|,
name|List
argument_list|<
name|IvyNode
argument_list|>
name|path
parameter_list|)
block|{
name|IvyNode
name|parent
init|=
name|node
operator|.
name|getDirectCallerFor
argument_list|(
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalArgumentException
argument_list|(
literal|"no path from "
operator|+
name|from
operator|+
literal|" to "
operator|+
name|getId
argument_list|()
operator|+
literal|" found"
argument_list|)
throw|;
block|}
if|if
condition|(
name|path
operator|.
name|contains
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|path
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
name|Message
operator|.
name|verbose
argument_list|(
literal|"circular dependency found while looking for the path for another one: was looking for "
operator|+
name|from
operator|+
literal|" as a caller of "
operator|+
name|path
operator|.
name|get
argument_list|(
name|path
operator|.
name|size
argument_list|()
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
name|path
operator|.
name|add
argument_list|(
literal|0
argument_list|,
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|.
name|getId
argument_list|()
operator|.
name|getModuleId
argument_list|()
operator|.
name|equals
argument_list|(
name|from
argument_list|)
condition|)
block|{
return|return
name|path
return|;
block|}
return|return
name|findPath
argument_list|(
name|from
argument_list|,
name|parent
argument_list|,
name|path
argument_list|)
return|;
block|}
comment|/**      * Update data in this node from data of the given node, for the given root module      * configuration.      *       * @param node      *            the source node from which data should be copied      * @param rootModuleConf      *            the root module configuration for which data should be updated      * @param real      *            true if the node to update from actually corresponds to the same real node      *            (usually updated because of dynamic revision resolution), false if it's not the      *            same real node (usually updated because of node eviction)      */
specifier|private
name|void
name|updateDataFrom
parameter_list|(
name|IvyNode
name|node
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|boolean
name|real
parameter_list|)
block|{
comment|// update callers
name|callers
operator|.
name|updateFrom
argument_list|(
name|node
operator|.
name|callers
argument_list|,
name|rootModuleConf
argument_list|,
name|real
argument_list|)
expr_stmt|;
if|if
condition|(
name|real
condition|)
block|{
name|usage
operator|.
name|updateDataFrom
argument_list|(
name|node
operator|.
name|getAllUsages
argument_list|()
argument_list|,
name|rootModuleConf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// let's copy usage information for the given rootModuleConf, into a separate usage
comment|// object to keep detailed data about where usage comes from
name|IvyNodeUsage
name|mergedUsage
init|=
name|mergedUsages
operator|.
name|get
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedUsage
operator|==
literal|null
condition|)
block|{
name|mergedUsage
operator|=
operator|new
name|IvyNodeUsage
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mergedUsages
operator|.
name|put
argument_list|(
name|node
operator|.
name|getId
argument_list|()
argument_list|,
name|mergedUsage
argument_list|)
expr_stmt|;
block|}
name|mergedUsage
operator|.
name|updateDataFrom
argument_list|(
name|node
operator|.
name|getAllUsages
argument_list|()
argument_list|,
name|rootModuleConf
argument_list|)
expr_stmt|;
block|}
comment|// update confsToFetch
name|updateConfsToFetch
argument_list|(
name|node
operator|.
name|fetchedConfigurations
argument_list|)
expr_stmt|;
name|updateConfsToFetch
argument_list|(
name|node
operator|.
name|confsToFetch
argument_list|)
expr_stmt|;
block|}
specifier|private
name|Collection
argument_list|<
name|IvyNodeUsage
argument_list|>
name|getAllUsages
parameter_list|()
block|{
name|Collection
argument_list|<
name|IvyNodeUsage
argument_list|>
name|usages
init|=
operator|new
name|ArrayList
argument_list|<
name|IvyNodeUsage
argument_list|>
argument_list|()
decl_stmt|;
name|usages
operator|.
name|add
argument_list|(
name|usage
argument_list|)
expr_stmt|;
name|usages
operator|.
name|addAll
argument_list|(
name|mergedUsages
operator|.
name|values
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|usages
return|;
block|}
comment|/**      * Returns all the artifacts of this dependency required in all the root module configurations      *       * @return array of {@link Artifact}s      */
specifier|public
name|Artifact
index|[]
name|getAllArtifacts
parameter_list|()
block|{
name|Set
argument_list|<
name|Artifact
argument_list|>
name|ret
init|=
operator|new
name|HashSet
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|rootModuleConf
range|:
name|getRootModuleConfigurationsSet
argument_list|()
control|)
block|{
name|ret
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getArtifacts
argument_list|(
name|rootModuleConf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|.
name|toArray
argument_list|(
operator|new
name|Artifact
index|[
name|ret
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Returns all the artifacts of this dependency required in the root module configurations in      * which the node is not evicted nor blacklisted      *       * @param artifactFilter Filter      * @return array of {@link Artifact}s      */
specifier|public
name|Artifact
index|[]
name|getSelectedArtifacts
parameter_list|(
name|Filter
argument_list|<
name|Artifact
argument_list|>
name|artifactFilter
parameter_list|)
block|{
name|Collection
argument_list|<
name|Artifact
argument_list|>
name|ret
init|=
operator|new
name|HashSet
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|String
name|rootModuleConf
range|:
name|getRootModuleConfigurationsSet
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|isEvicted
argument_list|(
name|rootModuleConf
argument_list|)
operator|&&
operator|!
name|isBlacklisted
argument_list|(
name|rootModuleConf
argument_list|)
condition|)
block|{
name|ret
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|getArtifacts
argument_list|(
name|rootModuleConf
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|FilterHelper
operator|.
name|filter
argument_list|(
name|ret
argument_list|,
name|artifactFilter
argument_list|)
expr_stmt|;
return|return
name|ret
operator|.
name|toArray
argument_list|(
operator|new
name|Artifact
index|[
name|ret
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
comment|/**      * Returns the artifacts of this dependency required in the configurations themselves required      * in the given root module configuration      *       * @param rootModuleConf String      * @return array of {@link Artifact}s      */
specifier|public
name|Artifact
index|[]
name|getArtifacts
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
comment|// first we look for the dependency configurations required
comment|// in the given root module configuration
name|String
index|[]
name|confs
init|=
name|getConfigurations
argument_list|(
name|rootModuleConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|confs
operator|==
literal|null
operator|||
name|confs
operator|.
name|length
operator|==
literal|0
condition|)
block|{
comment|// no configuration required => no artifact required
return|return
operator|new
name|Artifact
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"impossible to get artifacts when data has not been loaded. IvyNode = "
operator|+
name|this
argument_list|)
throw|;
block|}
name|Set
argument_list|<
name|Artifact
argument_list|>
name|artifacts
init|=
operator|new
name|HashSet
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
comment|// the set we fill before returning
comment|// we check if we have dependencyArtifacts includes description for this rootModuleConf
name|Set
argument_list|<
name|DependencyArtifactDescriptor
argument_list|>
name|dependencyArtifacts
init|=
name|usage
operator|.
name|getDependencyArtifactsSet
argument_list|(
name|rootModuleConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|md
operator|.
name|isDefault
argument_list|()
operator|&&
name|dependencyArtifacts
operator|!=
literal|null
operator|&&
operator|!
name|dependencyArtifacts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|addArtifactsFromOwnUsage
argument_list|(
name|artifacts
argument_list|,
name|dependencyArtifacts
argument_list|)
expr_stmt|;
name|addArtifactsFromMergedUsage
argument_list|(
name|rootModuleConf
argument_list|,
name|artifacts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Set
argument_list|<
name|IncludeRule
argument_list|>
name|includes
init|=
operator|new
name|LinkedHashSet
argument_list|<
name|IncludeRule
argument_list|>
argument_list|()
decl_stmt|;
name|addAllIfNotNull
argument_list|(
name|includes
argument_list|,
name|usage
operator|.
name|getDependencyIncludesSet
argument_list|(
name|rootModuleConf
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|IvyNodeUsage
name|usage
range|:
name|mergedUsages
operator|.
name|values
argument_list|()
control|)
block|{
name|addAllIfNotNull
argument_list|(
name|includes
argument_list|,
name|usage
operator|.
name|getDependencyIncludesSet
argument_list|(
name|rootModuleConf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dependencyArtifacts
operator|==
literal|null
operator|||
name|dependencyArtifacts
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
name|includes
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
comment|// no artifacts / includes: we get all artifacts as defined by the descriptor
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|confs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|artifacts
operator|.
name|addAll
argument_list|(
name|Arrays
operator|.
name|asList
argument_list|(
name|md
operator|.
name|getArtifacts
argument_list|(
name|confs
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// we have to get only artifacts listed as "includes"
comment|// first we get all artifacts as defined by the module descriptor
comment|// and classify them by artifact id
name|Map
argument_list|<
name|ArtifactId
argument_list|,
name|Artifact
argument_list|>
name|allArtifacts
init|=
operator|new
name|HashMap
argument_list|<
name|ArtifactId
argument_list|,
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|confs
operator|.
name|length
condition|;
name|i
operator|++
control|)
block|{
name|Artifact
index|[]
name|arts
init|=
name|md
operator|.
name|getArtifacts
argument_list|(
name|confs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|arts
operator|.
name|length
condition|;
name|j
operator|++
control|)
block|{
name|allArtifacts
operator|.
name|put
argument_list|(
name|arts
index|[
name|j
index|]
operator|.
name|getId
argument_list|()
operator|.
name|getArtifactId
argument_list|()
argument_list|,
name|arts
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|// now we add caller defined ones
if|if
condition|(
name|dependencyArtifacts
operator|!=
literal|null
condition|)
block|{
name|addArtifactsFromOwnUsage
argument_list|(
name|artifacts
argument_list|,
name|dependencyArtifacts
argument_list|)
expr_stmt|;
block|}
name|addArtifactsFromMergedUsage
argument_list|(
name|rootModuleConf
argument_list|,
name|artifacts
argument_list|)
expr_stmt|;
comment|// and now we filter according to include rules
for|for
control|(
name|Iterator
argument_list|<
name|IncludeRule
argument_list|>
name|it
init|=
name|includes
operator|.
name|iterator
argument_list|()
init|;
name|it
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|IncludeRule
name|dad
init|=
name|it
operator|.
name|next
argument_list|()
decl_stmt|;
name|Collection
argument_list|<
name|Artifact
argument_list|>
name|arts
init|=
name|findArtifactsMatching
argument_list|(
name|dad
argument_list|,
name|allArtifacts
argument_list|)
decl_stmt|;
if|if
condition|(
name|arts
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|Message
operator|.
name|error
argument_list|(
literal|"a required artifact is not listed by module descriptor: "
operator|+
name|dad
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
comment|// we remove it from required list to prevent message to be displayed more
comment|// than once
name|it
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|Message
operator|.
name|debug
argument_list|(
name|this
operator|+
literal|" in "
operator|+
name|rootModuleConf
operator|+
literal|": including "
operator|+
name|arts
argument_list|)
expr_stmt|;
name|artifacts
operator|.
name|addAll
argument_list|(
name|arts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|// now excludes artifacts that aren't accepted by any caller
for|for
control|(
name|Iterator
argument_list|<
name|Artifact
argument_list|>
name|iter
init|=
name|artifacts
operator|.
name|iterator
argument_list|()
init|;
name|iter
operator|.
name|hasNext
argument_list|()
condition|;
control|)
block|{
name|Artifact
name|artifact
init|=
name|iter
operator|.
name|next
argument_list|()
decl_stmt|;
name|boolean
name|excluded
init|=
name|callers
operator|.
name|doesCallersExclude
argument_list|(
name|rootModuleConf
argument_list|,
name|artifact
argument_list|)
decl_stmt|;
if|if
condition|(
name|excluded
condition|)
block|{
name|Message
operator|.
name|debug
argument_list|(
name|this
operator|+
literal|" in "
operator|+
name|rootModuleConf
operator|+
literal|": excluding "
operator|+
name|artifact
argument_list|)
expr_stmt|;
name|iter
operator|.
name|remove
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|artifacts
operator|.
name|toArray
argument_list|(
operator|new
name|Artifact
index|[
name|artifacts
operator|.
name|size
argument_list|()
index|]
argument_list|)
return|;
block|}
specifier|private
name|void
name|addArtifactsFromOwnUsage
parameter_list|(
name|Set
argument_list|<
name|Artifact
argument_list|>
name|artifacts
parameter_list|,
name|Set
argument_list|<
name|DependencyArtifactDescriptor
argument_list|>
name|dependencyArtifacts
parameter_list|)
block|{
for|for
control|(
name|DependencyArtifactDescriptor
name|dad
range|:
name|dependencyArtifacts
control|)
block|{
name|artifacts
operator|.
name|add
argument_list|(
operator|new
name|MDArtifact
argument_list|(
name|md
argument_list|,
name|dad
operator|.
name|getName
argument_list|()
argument_list|,
name|dad
operator|.
name|getType
argument_list|()
argument_list|,
name|dad
operator|.
name|getExt
argument_list|()
argument_list|,
name|dad
operator|.
name|getUrl
argument_list|()
argument_list|,
name|dad
operator|.
name|getQualifiedExtraAttributes
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|private
name|void
name|addArtifactsFromMergedUsage
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|Set
argument_list|<
name|Artifact
argument_list|>
name|artifacts
parameter_list|)
block|{
for|for
control|(
name|IvyNodeUsage
name|usage
range|:
name|mergedUsages
operator|.
name|values
argument_list|()
control|)
block|{
name|Set
argument_list|<
name|DependencyArtifactDescriptor
argument_list|>
name|mergedDependencyArtifacts
init|=
name|usage
operator|.
name|getDependencyArtifactsSet
argument_list|(
name|rootModuleConf
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergedDependencyArtifacts
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|DependencyArtifactDescriptor
name|dad
range|:
name|mergedDependencyArtifacts
control|)
block|{
name|Map
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
name|extraAttributes
init|=
operator|new
name|HashMap
argument_list|<
name|String
argument_list|,
name|String
argument_list|>
argument_list|(
name|dad
operator|.
name|getQualifiedExtraAttributes
argument_list|()
argument_list|)
decl_stmt|;
name|MDArtifact
name|artifact
init|=
operator|new
name|MDArtifact
argument_list|(
name|md
argument_list|,
name|dad
operator|.
name|getName
argument_list|()
argument_list|,
name|dad
operator|.
name|getType
argument_list|()
argument_list|,
name|dad
operator|.
name|getExt
argument_list|()
argument_list|,
name|dad
operator|.
name|getUrl
argument_list|()
argument_list|,
name|extraAttributes
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|artifacts
operator|.
name|contains
argument_list|(
name|artifact
argument_list|)
condition|)
block|{
comment|// this is later used to know that this is a merged artifact
name|extraAttributes
operator|.
name|put
argument_list|(
literal|"ivy:merged"
argument_list|,
name|dad
operator|.
name|getDependencyDescriptor
argument_list|()
operator|.
name|getParentRevisionId
argument_list|()
operator|+
literal|" -> "
operator|+
name|usage
operator|.
name|getNode
argument_list|()
operator|.
name|getId
argument_list|()
argument_list|)
expr_stmt|;
name|artifacts
operator|.
name|add
argument_list|(
name|artifact
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
specifier|private
specifier|static
name|Collection
argument_list|<
name|Artifact
argument_list|>
name|findArtifactsMatching
parameter_list|(
name|IncludeRule
name|rule
parameter_list|,
name|Map
argument_list|<
name|ArtifactId
argument_list|,
name|Artifact
argument_list|>
name|allArtifacts
parameter_list|)
block|{
name|Collection
argument_list|<
name|Artifact
argument_list|>
name|ret
init|=
operator|new
name|ArrayList
argument_list|<
name|Artifact
argument_list|>
argument_list|()
decl_stmt|;
for|for
control|(
name|Entry
argument_list|<
name|ArtifactId
argument_list|,
name|Artifact
argument_list|>
name|entry
range|:
name|allArtifacts
operator|.
name|entrySet
argument_list|()
control|)
block|{
if|if
condition|(
name|MatcherHelper
operator|.
name|matches
argument_list|(
name|rule
operator|.
name|getMatcher
argument_list|()
argument_list|,
name|rule
operator|.
name|getId
argument_list|()
argument_list|,
name|entry
operator|.
name|getKey
argument_list|()
argument_list|)
condition|)
block|{
name|ret
operator|.
name|add
argument_list|(
name|entry
operator|.
name|getValue
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
specifier|public
name|boolean
name|hasProblem
parameter_list|()
block|{
return|return
name|problem
operator|!=
literal|null
return|;
block|}
specifier|public
name|Exception
name|getProblem
parameter_list|()
block|{
return|return
name|problem
return|;
block|}
specifier|public
name|String
name|getProblemMessage
parameter_list|()
block|{
return|return
name|StringUtils
operator|.
name|getErrorMessage
argument_list|(
name|problem
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isDownloaded
parameter_list|()
block|{
return|return
name|downloaded
return|;
block|}
specifier|public
name|boolean
name|isSearched
parameter_list|()
block|{
return|return
name|searched
return|;
block|}
specifier|public
name|boolean
name|isLoaded
parameter_list|()
block|{
return|return
name|md
operator|!=
literal|null
return|;
block|}
specifier|public
name|boolean
name|isFetched
parameter_list|(
name|String
name|conf
parameter_list|)
block|{
return|return
name|fetchedConfigurations
operator|.
name|contains
argument_list|(
name|conf
argument_list|)
return|;
block|}
specifier|public
name|IvyNode
name|findNode
parameter_list|(
name|ModuleRevisionId
name|mrid
parameter_list|)
block|{
return|return
name|data
operator|.
name|getNode
argument_list|(
name|mrid
argument_list|)
return|;
block|}
name|boolean
name|isRoot
parameter_list|()
block|{
return|return
name|root
operator|==
name|this
return|;
block|}
specifier|public
name|IvyNode
name|getRoot
parameter_list|()
block|{
return|return
name|root
return|;
block|}
specifier|public
name|ConflictManager
name|getConflictManager
parameter_list|(
name|ModuleId
name|mid
parameter_list|)
block|{
if|if
condition|(
name|md
operator|==
literal|null
condition|)
block|{
throw|throw
operator|new
name|IllegalStateException
argument_list|(
literal|"impossible to get conflict manager when data has not been loaded. IvyNode = "
operator|+
name|this
argument_list|)
throw|;
block|}
name|ConflictManager
name|cm
init|=
name|md
operator|.
name|getConflictManager
argument_list|(
name|mid
argument_list|)
decl_stmt|;
return|return
name|cm
operator|==
literal|null
condition|?
name|settings
operator|.
name|getConflictManager
argument_list|(
name|mid
argument_list|)
else|:
name|cm
return|;
block|}
specifier|public
name|IvyNode
name|getRealNode
parameter_list|()
block|{
name|IvyNode
name|real
init|=
name|data
operator|.
name|getNode
argument_list|(
name|getId
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|real
operator|!=
literal|null
condition|?
name|real
else|:
name|this
return|;
block|}
specifier|public
name|ModuleRevisionId
name|getId
parameter_list|()
block|{
return|return
name|id
return|;
block|}
specifier|public
name|ModuleId
name|getModuleId
parameter_list|()
block|{
return|return
name|id
operator|.
name|getModuleId
argument_list|()
return|;
block|}
specifier|public
name|ModuleDescriptor
name|getDescriptor
parameter_list|()
block|{
return|return
name|md
return|;
block|}
specifier|public
name|ResolveData
name|getData
parameter_list|()
block|{
return|return
name|data
return|;
block|}
specifier|public
name|ResolvedModuleRevision
name|getModuleRevision
parameter_list|()
block|{
return|return
name|module
return|;
block|}
specifier|public
name|long
name|getPublication
parameter_list|()
block|{
if|if
condition|(
name|module
operator|!=
literal|null
condition|)
block|{
return|return
name|module
operator|.
name|getPublicationDate
argument_list|()
operator|.
name|getTime
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
comment|/**      * Returns the last modified timestamp of the module represented by this Node, or 0 if the last      * modified timestamp is currently unknown (module not loaded)      *       * @return the last modified timestamp of the module represented by this Node      */
specifier|public
name|long
name|getLastModified
parameter_list|()
block|{
if|if
condition|(
name|md
operator|!=
literal|null
condition|)
block|{
return|return
name|md
operator|.
name|getLastModified
argument_list|()
return|;
block|}
return|return
literal|0
return|;
block|}
specifier|public
name|ModuleRevisionId
name|getResolvedId
parameter_list|()
block|{
if|if
condition|(
name|md
operator|!=
literal|null
operator|&&
name|md
operator|.
name|getResolvedModuleRevisionId
argument_list|()
operator|.
name|getRevision
argument_list|()
operator|!=
literal|null
condition|)
block|{
return|return
name|md
operator|.
name|getResolvedModuleRevisionId
argument_list|()
return|;
block|}
if|if
condition|(
name|module
operator|!=
literal|null
condition|)
block|{
return|return
name|module
operator|.
name|getId
argument_list|()
return|;
block|}
return|return
name|getId
argument_list|()
return|;
block|}
comment|/**      * Clean data related to one root module configuration only      */
specifier|public
name|void
name|clean
parameter_list|()
block|{
name|confsToFetch
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// /////////////////////////////////////////////////////////////////////////////
comment|// CALLERS MANAGEMENT
comment|// /////////////////////////////////////////////////////////////////////////////
name|boolean
name|canExclude
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
for|for
control|(
name|Caller
name|caller
range|:
name|getCallers
argument_list|(
name|rootModuleConf
argument_list|)
control|)
block|{
if|if
condition|(
name|caller
operator|.
name|canExclude
argument_list|()
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
specifier|private
name|IvyNode
name|getDirectCallerFor
parameter_list|(
name|ModuleId
name|from
parameter_list|)
block|{
return|return
name|callers
operator|.
name|getDirectCallerFor
argument_list|(
name|from
argument_list|)
return|;
block|}
specifier|public
name|Caller
index|[]
name|getCallers
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|callers
operator|.
name|getCallers
argument_list|(
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|ModuleId
argument_list|>
name|getAllCallersModuleIds
parameter_list|()
block|{
return|return
name|callers
operator|.
name|getAllCallersModuleIds
argument_list|()
return|;
block|}
specifier|public
name|Caller
index|[]
name|getAllCallers
parameter_list|()
block|{
return|return
name|callers
operator|.
name|getAllCallers
argument_list|()
return|;
block|}
specifier|public
name|Caller
index|[]
name|getAllRealCallers
parameter_list|()
block|{
return|return
name|callers
operator|.
name|getAllRealCallers
argument_list|()
return|;
block|}
specifier|public
name|void
name|addCaller
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|IvyNode
name|callerNode
parameter_list|,
name|String
name|callerConf
parameter_list|,
name|String
name|requestedConf
parameter_list|,
name|String
index|[]
name|dependencyConfs
parameter_list|,
name|DependencyDescriptor
name|dd
parameter_list|)
block|{
name|callers
operator|.
name|addCaller
argument_list|(
name|rootModuleConf
argument_list|,
name|callerNode
argument_list|,
name|callerConf
argument_list|,
name|requestedConf
argument_list|,
name|dependencyConfs
argument_list|,
name|dd
argument_list|)
expr_stmt|;
name|boolean
name|isCircular
init|=
name|callers
operator|.
name|getAllCallersModuleIds
argument_list|()
operator|.
name|contains
argument_list|(
name|getId
argument_list|()
operator|.
name|getModuleId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|isCircular
condition|)
block|{
name|IvyContext
operator|.
name|getContext
argument_list|()
operator|.
name|getCircularDependencyStrategy
argument_list|()
operator|.
name|handleCircularDependency
argument_list|(
name|toMrids
argument_list|(
name|findPath
argument_list|(
name|getId
argument_list|()
operator|.
name|getModuleId
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
specifier|public
name|boolean
name|doesCallersExclude
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|Artifact
name|artifact
parameter_list|,
name|Stack
argument_list|<
name|ModuleRevisionId
argument_list|>
name|callersStack
parameter_list|)
block|{
return|return
name|callers
operator|.
name|doesCallersExclude
argument_list|(
name|rootModuleConf
argument_list|,
name|artifact
argument_list|,
name|callersStack
argument_list|)
return|;
block|}
specifier|private
name|ModuleRevisionId
index|[]
name|toMrids
parameter_list|(
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|path
parameter_list|,
name|IvyNode
name|depNode
parameter_list|)
block|{
name|ModuleRevisionId
index|[]
name|ret
init|=
operator|new
name|ModuleRevisionId
index|[
name|path
operator|.
name|size
argument_list|()
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|IvyNode
name|node
range|:
name|path
control|)
block|{
name|ret
index|[
name|i
operator|++
index|]
operator|=
name|node
operator|.
name|getId
argument_list|()
expr_stmt|;
block|}
name|ret
index|[
name|ret
operator|.
name|length
operator|-
literal|1
index|]
operator|=
name|depNode
operator|.
name|getId
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|// /////////////////////////////////////////////////////////////////////////////
comment|// EVICTION MANAGEMENT
comment|// /////////////////////////////////////////////////////////////////////////////
comment|/** A copy of the set of resolved nodes (real nodes) */
specifier|public
name|Set
argument_list|<
name|IvyNode
argument_list|>
name|getResolvedNodes
parameter_list|(
name|ModuleId
name|moduleId
parameter_list|,
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|getResolvedNodes
argument_list|(
name|moduleId
argument_list|,
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|ModuleRevisionId
argument_list|>
name|getResolvedRevisions
parameter_list|(
name|ModuleId
name|moduleId
parameter_list|,
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|getResolvedRevisions
argument_list|(
name|moduleId
argument_list|,
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|void
name|markEvicted
parameter_list|(
name|EvictionData
name|evictionData
parameter_list|)
block|{
name|eviction
operator|.
name|markEvicted
argument_list|(
name|evictionData
argument_list|)
expr_stmt|;
name|String
name|rootModuleConf
init|=
name|evictionData
operator|.
name|getRootModuleConf
argument_list|()
decl_stmt|;
comment|// bug 105: update selected data with evicted one
if|if
condition|(
name|evictionData
operator|.
name|getSelected
argument_list|()
operator|!=
literal|null
condition|)
block|{
for|for
control|(
name|IvyNode
name|selected
range|:
name|evictionData
operator|.
name|getSelected
argument_list|()
control|)
block|{
name|selected
operator|.
name|updateDataFrom
argument_list|(
name|this
argument_list|,
name|rootModuleConf
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
specifier|public
name|Collection
argument_list|<
name|ConflictManager
argument_list|>
name|getAllEvictingConflictManagers
parameter_list|()
block|{
return|return
name|eviction
operator|.
name|getAllEvictingConflictManagers
argument_list|()
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|getAllEvictingNodes
parameter_list|()
block|{
return|return
name|eviction
operator|.
name|getAllEvictingNodes
argument_list|()
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|String
argument_list|>
name|getAllEvictingNodesDetails
parameter_list|()
block|{
return|return
name|eviction
operator|.
name|getAllEvictingNodesDetails
argument_list|()
return|;
block|}
specifier|public
name|String
index|[]
name|getEvictedConfs
parameter_list|()
block|{
return|return
name|eviction
operator|.
name|getEvictedConfs
argument_list|()
return|;
block|}
specifier|public
name|EvictionData
name|getEvictedData
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|getEvictedData
argument_list|(
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|getEvictedNodes
parameter_list|(
name|ModuleId
name|mid
parameter_list|,
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|getEvictedNodes
argument_list|(
name|mid
argument_list|,
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|Collection
argument_list|<
name|ModuleRevisionId
argument_list|>
name|getEvictedRevisions
parameter_list|(
name|ModuleId
name|mid
parameter_list|,
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|getEvictedRevisions
argument_list|(
name|mid
argument_list|,
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|EvictionData
name|getEvictionDataInRoot
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|IvyNode
name|ancestor
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|getEvictionDataInRoot
argument_list|(
name|rootModuleConf
argument_list|,
name|ancestor
argument_list|)
return|;
block|}
specifier|public
name|boolean
name|isCompletelyEvicted
parameter_list|()
block|{
return|return
name|eviction
operator|.
name|isCompletelyEvicted
argument_list|()
return|;
block|}
specifier|public
name|boolean
name|isEvicted
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|isEvicted
argument_list|(
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|void
name|markEvicted
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|IvyNode
name|node
parameter_list|,
name|ConflictManager
name|conflictManager
parameter_list|,
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|resolved
parameter_list|)
block|{
name|EvictionData
name|evictionData
init|=
operator|new
name|EvictionData
argument_list|(
name|rootModuleConf
argument_list|,
name|node
argument_list|,
name|conflictManager
argument_list|,
name|resolved
argument_list|)
decl_stmt|;
name|markEvicted
argument_list|(
name|evictionData
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setEvictedNodes
parameter_list|(
name|ModuleId
name|moduleId
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|evicted
parameter_list|)
block|{
name|eviction
operator|.
name|setEvictedNodes
argument_list|(
name|moduleId
argument_list|,
name|rootModuleConf
argument_list|,
name|evicted
argument_list|)
expr_stmt|;
block|}
specifier|public
name|void
name|setResolvedNodes
parameter_list|(
name|ModuleId
name|moduleId
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|resolved
parameter_list|)
block|{
name|eviction
operator|.
name|setResolvedNodes
argument_list|(
name|moduleId
argument_list|,
name|rootModuleConf
argument_list|,
name|resolved
argument_list|)
expr_stmt|;
block|}
annotation|@
name|Override
specifier|public
name|String
name|toString
parameter_list|()
block|{
return|return
name|getResolvedId
argument_list|()
operator|.
name|toString
argument_list|()
return|;
block|}
annotation|@
name|Override
specifier|public
name|boolean
name|equals
parameter_list|(
name|Object
name|obj
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|obj
operator|instanceof
name|IvyNode
operator|)
condition|)
block|{
return|return
literal|false
return|;
block|}
name|IvyNode
name|node
init|=
operator|(
name|IvyNode
operator|)
name|obj
decl_stmt|;
return|return
name|node
operator|.
name|getId
argument_list|()
operator|.
name|equals
argument_list|(
name|getId
argument_list|()
argument_list|)
return|;
block|}
specifier|public
name|int
name|compareTo
parameter_list|(
name|IvyNode
name|that
parameter_list|)
block|{
return|return
name|this
operator|.
name|getModuleId
argument_list|()
operator|.
name|compareTo
argument_list|(
name|that
operator|.
name|getModuleId
argument_list|()
argument_list|)
return|;
block|}
annotation|@
name|Override
specifier|public
name|int
name|hashCode
parameter_list|()
block|{
return|return
name|getId
argument_list|()
operator|.
name|hashCode
argument_list|()
return|;
block|}
comment|/**      * Returns a collection of Nodes in conflict for which conflict has been detected but conflict      * resolution hasn't been done yet      *       * @param rootModuleConf ditto      * @param mid      *            the module id for which pending conflicts should be found      * @return a Collection of IvyNode in pending conflict      */
specifier|public
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|getPendingConflicts
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|ModuleId
name|mid
parameter_list|)
block|{
return|return
name|eviction
operator|.
name|getPendingConflicts
argument_list|(
name|rootModuleConf
argument_list|,
name|mid
argument_list|)
return|;
block|}
specifier|public
name|void
name|setPendingConflicts
parameter_list|(
name|ModuleId
name|moduleId
parameter_list|,
name|String
name|rootModuleConf
parameter_list|,
name|Collection
argument_list|<
name|IvyNode
argument_list|>
name|conflicts
parameter_list|)
block|{
name|eviction
operator|.
name|setPendingConflicts
argument_list|(
name|moduleId
argument_list|,
name|rootModuleConf
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
block|}
comment|// /////////////////////////////////////////////////////////////////////////////
comment|// BLACKLISTING MANAGEMENT
comment|// /////////////////////////////////////////////////////////////////////////////
comment|/**      * Blacklists the current node, so that a new resolve process won't ever consider this node as      * available in the repository.      *<p>      * This is useful in combination with {@link RestartResolveProcess} for conflict manager      * implementation which use a best effort strategy to find compatible dependency set, like      * {@link LatestCompatibleConflictManager}      *</p>      *       * @param bdata      *            the root module configuration in which the node should be blacklisted      */
specifier|public
name|void
name|blacklist
parameter_list|(
name|IvyNodeBlacklist
name|bdata
parameter_list|)
block|{
if|if
condition|(
name|data
operator|.
name|getSettings
argument_list|()
operator|.
name|logResolvedRevision
argument_list|()
condition|)
block|{
name|Message
operator|.
name|info
argument_list|(
literal|"BLACKLISTING "
operator|+
name|bdata
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Message
operator|.
name|verbose
argument_list|(
literal|"BLACKLISTING "
operator|+
name|bdata
argument_list|)
expr_stmt|;
block|}
name|Stack
argument_list|<
name|IvyNode
argument_list|>
name|callerStack
init|=
operator|new
name|Stack
argument_list|<
name|IvyNode
argument_list|>
argument_list|()
decl_stmt|;
name|callerStack
operator|.
name|push
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|clearEvictionDataInAllCallers
argument_list|(
name|bdata
operator|.
name|getRootModuleConf
argument_list|()
argument_list|,
name|callerStack
argument_list|)
expr_stmt|;
name|usage
operator|.
name|blacklist
argument_list|(
name|bdata
argument_list|)
expr_stmt|;
name|data
operator|.
name|blacklist
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
specifier|private
name|void
name|clearEvictionDataInAllCallers
parameter_list|(
name|String
name|rootModuleConf
parameter_list|,
name|Stack
argument_list|<
name|IvyNode
argument_list|>
name|callerStack
parameter_list|)
block|{
for|for
control|(
name|Caller
name|caller
range|:
name|callerStack
operator|.
name|peek
argument_list|()
operator|.
name|getCallers
argument_list|(
name|rootModuleConf
argument_list|)
control|)
block|{
name|IvyNode
name|callerNode
init|=
name|findNode
argument_list|(
name|caller
operator|.
name|getModuleRevisionId
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|callerNode
operator|!=
literal|null
condition|)
block|{
name|callerNode
operator|.
name|eviction
operator|=
operator|new
name|IvyNodeEviction
argument_list|(
name|callerNode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callerStack
operator|.
name|contains
argument_list|(
name|callerNode
argument_list|)
condition|)
block|{
name|callerStack
operator|.
name|push
argument_list|(
name|callerNode
argument_list|)
expr_stmt|;
name|clearEvictionDataInAllCallers
argument_list|(
name|rootModuleConf
argument_list|,
name|callerStack
argument_list|)
expr_stmt|;
name|callerStack
operator|.
name|pop
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/**      * Indicates if this node has been blacklisted in the given root module conf.      *<p>      * A blacklisted node should be considered as if it doesn't even exist on the repository.      *</p>      *       * @param rootModuleConf      *            the root module conf for which we'd like to know if the node is blacklisted      *       * @return true if this node is blacklisted int he given root module conf, false otherwise      * @see #blacklist(IvyNodeBlacklist)      */
specifier|public
name|boolean
name|isBlacklisted
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|usage
operator|.
name|isBlacklisted
argument_list|(
name|rootModuleConf
argument_list|)
return|;
block|}
comment|/**      * Indicates if this node has been blacklisted in all root module configurations.      *       * @return true if this node is blacklisted in all root module configurations, false otherwise      * @see #blacklist(IvyNodeBlacklist)      */
specifier|public
name|boolean
name|isCompletelyBlacklisted
parameter_list|()
block|{
if|if
condition|(
name|isRoot
argument_list|()
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|String
name|rootModuleConfiguration
range|:
name|getRootModuleConfigurations
argument_list|()
control|)
block|{
if|if
condition|(
operator|!
name|isBlacklisted
argument_list|(
name|rootModuleConfiguration
argument_list|)
condition|)
block|{
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
comment|/**      * Returns the blacklist data of this node in the given root module conf, or<code>null</code>      * if this node is not blacklisted in this root module conf.      *       * @param rootModuleConf      *            the root module configuration to consider      * @return the blacklist data if any      */
specifier|public
name|IvyNodeBlacklist
name|getBlacklistData
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
return|return
name|usage
operator|.
name|getBlacklistData
argument_list|(
name|rootModuleConf
argument_list|)
return|;
block|}
specifier|public
name|IvyNodeUsage
name|getMainUsage
parameter_list|()
block|{
return|return
name|usage
return|;
block|}
comment|/**      * Indicates if there is any of the merged usages of this node which has a depender with      * transitive dependency descriptor.      *<p>      * If at there is at least one usage from the merged usages for which there is a depender in the      * given root module conf which has a dependency descriptor with transitive == true, then it      * returns true. Otherwise it returns false.      *</p>      *       * @param rootModuleConf      *            the root module configuration to consider      * @return true if there is any merged usage with transitive dd, false otherwise.      */
specifier|public
name|boolean
name|hasAnyMergedUsageWithTransitiveDependency
parameter_list|(
name|String
name|rootModuleConf
parameter_list|)
block|{
if|if
condition|(
name|mergedUsages
operator|==
literal|null
condition|)
block|{
return|return
literal|false
return|;
block|}
for|for
control|(
name|IvyNodeUsage
name|usage
range|:
name|mergedUsages
operator|.
name|values
argument_list|()
control|)
block|{
if|if
condition|(
name|usage
operator|.
name|hasTransitiveDepender
argument_list|(
name|rootModuleConf
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
block|}
return|return
literal|false
return|;
block|}
block|}
end_class

end_unit

